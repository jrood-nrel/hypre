/******************************************************************************
 * Copyright (c) 1998 Lawrence Livermore National Security, LLC and other
 * HYPRE Project Developers. See the top-level COPYRIGHT file for details.
 *
 * SPDX-License-Identifier: (Apache-2.0 OR MIT)
 ******************************************************************************/

/******************************************************************************
 *
 * Schwarz functions
 *
 *****************************************************************************/

#include "_nalu_hypre_parcsr_ls.h"
#include "schwarz.h"

/*--------------------------------------------------------------------------
 * nalu_hypre_SchwarzCreate
 *--------------------------------------------------------------------------*/

void *
nalu_hypre_SchwarzCreate()
{
   nalu_hypre_SchwarzData *schwarz_data;

   NALU_HYPRE_Int      variant;
   NALU_HYPRE_Int      domain_type;
   NALU_HYPRE_Int      overlap;
   NALU_HYPRE_Int      num_functions;
   NALU_HYPRE_Int      use_nonsymm;
   NALU_HYPRE_Real     relax_weight;

   /*-----------------------------------------------------------------------
    * Setup default values for parameters
    *-----------------------------------------------------------------------*/

   /* setup params */
   variant = 0;  /* multiplicative Schwarz */
   overlap = 1;  /* minimal overlap */
   domain_type = 2; /* domains generated by agglomeration */
   num_functions = 1;
   use_nonsymm = 0;
   relax_weight = 1.0;

   schwarz_data = nalu_hypre_CTAlloc(nalu_hypre_SchwarzData, 1, NALU_HYPRE_MEMORY_HOST);

   nalu_hypre_SchwarzSetVariant(schwarz_data, variant);
   nalu_hypre_SchwarzSetDomainType(schwarz_data, domain_type);
   nalu_hypre_SchwarzSetOverlap(schwarz_data, overlap);
   nalu_hypre_SchwarzSetNumFunctions(schwarz_data, num_functions);
   nalu_hypre_SchwarzSetNonSymm(schwarz_data, use_nonsymm);
   nalu_hypre_SchwarzSetRelaxWeight(schwarz_data, relax_weight);

   nalu_hypre_SchwarzDataDomainStructure(schwarz_data) = NULL;
   nalu_hypre_SchwarzDataABoundary(schwarz_data) = NULL;
   nalu_hypre_SchwarzDataScale(schwarz_data) = NULL;
   nalu_hypre_SchwarzDataVtemp(schwarz_data) = NULL;
   nalu_hypre_SchwarzDataDofFunc(schwarz_data) = NULL;

   return (void *) schwarz_data;
}

/*--------------------------------------------------------------------------
 * nalu_hypre_SchwarzDestroy
 *--------------------------------------------------------------------------*/

NALU_HYPRE_Int
nalu_hypre_SchwarzDestroy( void *data )
{
   nalu_hypre_SchwarzData  *schwarz_data = (nalu_hypre_SchwarzData*) data;

   if (nalu_hypre_SchwarzDataScale(schwarz_data))
   {
      nalu_hypre_TFree(nalu_hypre_SchwarzDataScale(schwarz_data), NALU_HYPRE_MEMORY_HOST);
   }
   if (nalu_hypre_SchwarzDataDofFunc(schwarz_data))
   {
      nalu_hypre_TFree(nalu_hypre_SchwarzDataDofFunc(schwarz_data), NALU_HYPRE_MEMORY_HOST);
   }
   nalu_hypre_CSRMatrixDestroy(nalu_hypre_SchwarzDataDomainStructure(schwarz_data));
   if (nalu_hypre_SchwarzDataVariant(schwarz_data) == 3)
   {
      nalu_hypre_CSRMatrixDestroy(nalu_hypre_SchwarzDataABoundary(schwarz_data));
   }
   nalu_hypre_ParVectorDestroy(nalu_hypre_SchwarzDataVtemp(schwarz_data));

   if (nalu_hypre_SchwarzDataPivots(schwarz_data))
   {
      nalu_hypre_TFree(nalu_hypre_SchwarzDataPivots(schwarz_data), NALU_HYPRE_MEMORY_HOST);
   }


   nalu_hypre_TFree(schwarz_data, NALU_HYPRE_MEMORY_HOST);
   return nalu_hypre_error_flag;

}

NALU_HYPRE_Int
nalu_hypre_SchwarzSetup(void               *schwarz_vdata,
                   nalu_hypre_ParCSRMatrix *A,
                   nalu_hypre_ParVector    *f,
                   nalu_hypre_ParVector    *u         )
{

   nalu_hypre_SchwarzData   *schwarz_data = (nalu_hypre_SchwarzData*) schwarz_vdata;
   NALU_HYPRE_Int *dof_func;
   NALU_HYPRE_Real *scale;
   nalu_hypre_CSRMatrix *domain_structure;
   nalu_hypre_CSRMatrix *A_boundary;
   nalu_hypre_ParVector *Vtemp;

   NALU_HYPRE_Int *pivots = NULL;

   NALU_HYPRE_Int variant = nalu_hypre_SchwarzDataVariant(schwarz_data);
   NALU_HYPRE_Int domain_type = nalu_hypre_SchwarzDataDomainType(schwarz_data);
   NALU_HYPRE_Int overlap = nalu_hypre_SchwarzDataOverlap(schwarz_data);
   NALU_HYPRE_Int num_functions = nalu_hypre_SchwarzDataNumFunctions(schwarz_data);
   NALU_HYPRE_Real relax_weight = nalu_hypre_SchwarzDataRelaxWeight(schwarz_data);
   NALU_HYPRE_Int use_nonsymm = nalu_hypre_SchwarzDataUseNonSymm(schwarz_data);


   dof_func = nalu_hypre_SchwarzDataDofFunc(schwarz_data);

   Vtemp = nalu_hypre_ParVectorCreate(nalu_hypre_ParCSRMatrixComm(A),
                                 nalu_hypre_ParCSRMatrixGlobalNumRows(A),
                                 nalu_hypre_ParCSRMatrixRowStarts(A));
   nalu_hypre_ParVectorInitialize(Vtemp);
   nalu_hypre_SchwarzDataVtemp(schwarz_data) = Vtemp;

   if (variant > 1)
   {
      nalu_hypre_ParAMGCreateDomainDof(A,
                                  domain_type, overlap,
                                  num_functions, dof_func,
                                  &domain_structure, &pivots, use_nonsymm);

      if (domain_structure)
      {
         if (variant == 2)
         {
            nalu_hypre_ParGenerateScale(A, domain_structure, relax_weight,
                                   &scale);
            nalu_hypre_SchwarzDataScale(schwarz_data) = scale;
         }
         else
         {
            nalu_hypre_ParGenerateHybridScale(A, domain_structure, &A_boundary, &scale);
            nalu_hypre_SchwarzDataScale(schwarz_data) = scale;
            if (nalu_hypre_CSRMatrixNumCols(nalu_hypre_ParCSRMatrixOffd(A)))
            {
               nalu_hypre_SchwarzDataABoundary(schwarz_data) = A_boundary;
            }
            else
            {
               nalu_hypre_SchwarzDataABoundary(schwarz_data) = NULL;
            }
         }
      }
   }
   else
   {
      nalu_hypre_AMGCreateDomainDof (nalu_hypre_ParCSRMatrixDiag(A),
                                domain_type, overlap,
                                num_functions, dof_func,
                                &domain_structure, &pivots, use_nonsymm);
      if (domain_structure)
      {
         if (variant == 1)
         {
            nalu_hypre_GenerateScale(domain_structure,
                                nalu_hypre_CSRMatrixNumRows(nalu_hypre_ParCSRMatrixDiag(A)),
                                relax_weight, &scale);
            nalu_hypre_SchwarzDataScale(schwarz_data) = scale;
         }
      }
   }

   nalu_hypre_SchwarzDataDomainStructure(schwarz_data) = domain_structure;
   nalu_hypre_SchwarzDataPivots(schwarz_data) = pivots;

   return nalu_hypre_error_flag;

}

/*--------------------------------------------------------------------
 * nalu_hypre_SchwarzSolve
 *--------------------------------------------------------------------*/

NALU_HYPRE_Int
nalu_hypre_SchwarzSolve(void               *schwarz_vdata,
                   nalu_hypre_ParCSRMatrix *A,
                   nalu_hypre_ParVector    *f,
                   nalu_hypre_ParVector    *u         )
{
   nalu_hypre_SchwarzData   *schwarz_data = (nalu_hypre_SchwarzData*) schwarz_vdata;

   nalu_hypre_CSRMatrix *domain_structure =
      nalu_hypre_SchwarzDataDomainStructure(schwarz_data);
   nalu_hypre_CSRMatrix *A_boundary = nalu_hypre_SchwarzDataABoundary(schwarz_data);
   NALU_HYPRE_Real *scale = nalu_hypre_SchwarzDataScale(schwarz_data);
   nalu_hypre_ParVector *Vtemp = nalu_hypre_SchwarzDataVtemp(schwarz_data);
   NALU_HYPRE_Int variant = nalu_hypre_SchwarzDataVariant(schwarz_data);
   NALU_HYPRE_Real relax_wt = nalu_hypre_SchwarzDataRelaxWeight(schwarz_data);
   NALU_HYPRE_Int use_nonsymm = nalu_hypre_SchwarzDataUseNonSymm(schwarz_data);

   NALU_HYPRE_Int *pivots = nalu_hypre_SchwarzDataPivots(schwarz_data);

   if (domain_structure)
   {
      if (variant == 2)
      {
         nalu_hypre_ParAdSchwarzSolve(A, f, domain_structure, scale, u, Vtemp, pivots, use_nonsymm);
      }
      else if (variant == 3)
      {
         nalu_hypre_ParMPSchwarzSolve(A, A_boundary, f, domain_structure, u,
                                 relax_wt, scale, Vtemp, pivots, use_nonsymm);
      }
      else if (variant == 1)
      {
         nalu_hypre_AdSchwarzSolve(A, f, domain_structure, scale, u, Vtemp, pivots, use_nonsymm);
      }
      else if (variant == 4)
      {
         nalu_hypre_MPSchwarzFWSolve(A, nalu_hypre_ParVectorLocalVector(f),
                                domain_structure, u, relax_wt,
                                nalu_hypre_ParVectorLocalVector(Vtemp), pivots, use_nonsymm);
      }
      else
      {
         nalu_hypre_MPSchwarzSolve(A, nalu_hypre_ParVectorLocalVector(f),
                              domain_structure, u, relax_wt,
                              nalu_hypre_ParVectorLocalVector(Vtemp), pivots, use_nonsymm);
      }
   }

   return nalu_hypre_error_flag;
}
/*--------------------------------------------------------------------
 * nalu_hypre_SchwarzCFSolve
 *--------------------------------------------------------------------*/

NALU_HYPRE_Int
nalu_hypre_SchwarzCFSolve(void               *schwarz_vdata,
                     nalu_hypre_ParCSRMatrix *A,
                     nalu_hypre_ParVector    *f,
                     nalu_hypre_ParVector    *u,
                     NALU_HYPRE_Int *CF_marker,
                     NALU_HYPRE_Int rlx_pt)
{
   nalu_hypre_SchwarzData   *schwarz_data = (nalu_hypre_SchwarzData*) schwarz_vdata;

   nalu_hypre_CSRMatrix *domain_structure =
      nalu_hypre_SchwarzDataDomainStructure(schwarz_data);
   NALU_HYPRE_Real *scale = nalu_hypre_SchwarzDataScale(schwarz_data);
   nalu_hypre_ParVector *Vtemp = nalu_hypre_SchwarzDataVtemp(schwarz_data);
   NALU_HYPRE_Int variant = nalu_hypre_SchwarzDataVariant(schwarz_data);
   NALU_HYPRE_Real relax_wt = nalu_hypre_SchwarzDataRelaxWeight(schwarz_data);

   NALU_HYPRE_Int use_nonsymm = nalu_hypre_SchwarzDataUseNonSymm(schwarz_data);

   NALU_HYPRE_Int *pivots = nalu_hypre_SchwarzDataPivots(schwarz_data);

   if (variant == 1)
   {
      nalu_hypre_AdSchwarzCFSolve(A, f, domain_structure, scale, u, Vtemp,
                             CF_marker, rlx_pt, pivots, use_nonsymm);
   }
   else if (variant == 4)
   {
      nalu_hypre_MPSchwarzCFFWSolve(A, nalu_hypre_ParVectorLocalVector(f),
                               domain_structure, u, relax_wt,
                               nalu_hypre_ParVectorLocalVector(Vtemp),
                               CF_marker, rlx_pt, pivots, use_nonsymm);
   }
   else
   {
      nalu_hypre_MPSchwarzCFSolve(A, nalu_hypre_ParVectorLocalVector(f),
                             domain_structure, u, relax_wt,
                             nalu_hypre_ParVectorLocalVector(Vtemp),
                             CF_marker, rlx_pt, pivots, use_nonsymm);
   }

   return nalu_hypre_error_flag;
}

/*--------------------------------------------------------------------------
 * Routines to set various parameters
 *--------------------------------------------------------------------------*/

NALU_HYPRE_Int
nalu_hypre_SchwarzSetVariant( void *data, NALU_HYPRE_Int variant )
{

   nalu_hypre_SchwarzData  *schwarz_data = (nalu_hypre_SchwarzData*) data;

   nalu_hypre_SchwarzDataVariant(schwarz_data) = variant;
   return nalu_hypre_error_flag;

}

NALU_HYPRE_Int
nalu_hypre_SchwarzSetDomainType( void *data, NALU_HYPRE_Int domain_type )
{

   nalu_hypre_SchwarzData  *schwarz_data = (nalu_hypre_SchwarzData*) data;

   nalu_hypre_SchwarzDataDomainType(schwarz_data) = domain_type;
   return nalu_hypre_error_flag;

}

NALU_HYPRE_Int
nalu_hypre_SchwarzSetOverlap( void *data, NALU_HYPRE_Int overlap )
{

   nalu_hypre_SchwarzData  *schwarz_data = (nalu_hypre_SchwarzData*) data;

   nalu_hypre_SchwarzDataOverlap(schwarz_data) = overlap;

   return nalu_hypre_error_flag;
}

NALU_HYPRE_Int
nalu_hypre_SchwarzSetNumFunctions( void *data, NALU_HYPRE_Int num_functions )
{

   nalu_hypre_SchwarzData  *schwarz_data = (nalu_hypre_SchwarzData*) data;

   nalu_hypre_SchwarzDataNumFunctions(schwarz_data) = num_functions;

   return nalu_hypre_error_flag;
}

NALU_HYPRE_Int
nalu_hypre_SchwarzSetNonSymm( void *data, NALU_HYPRE_Int value )
{

   nalu_hypre_SchwarzData  *schwarz_data = (nalu_hypre_SchwarzData*) data;

   nalu_hypre_SchwarzDataUseNonSymm(schwarz_data) = value;

   return nalu_hypre_error_flag;

}

NALU_HYPRE_Int
nalu_hypre_SchwarzSetRelaxWeight( void *data, NALU_HYPRE_Real relax_weight )
{

   nalu_hypre_SchwarzData  *schwarz_data = (nalu_hypre_SchwarzData*) data;

   nalu_hypre_SchwarzDataRelaxWeight(schwarz_data) = relax_weight;

   return nalu_hypre_error_flag;
}

NALU_HYPRE_Int
nalu_hypre_SchwarzSetDomainStructure( void *data, nalu_hypre_CSRMatrix *domain_structure )
{

   nalu_hypre_SchwarzData  *schwarz_data = (nalu_hypre_SchwarzData*) data;

   nalu_hypre_SchwarzDataDomainStructure(schwarz_data) = domain_structure;

   return nalu_hypre_error_flag;
}

NALU_HYPRE_Int
nalu_hypre_SchwarzSetScale( void *data, NALU_HYPRE_Real *scale)
{

   nalu_hypre_SchwarzData  *schwarz_data = (nalu_hypre_SchwarzData*) data;

   nalu_hypre_SchwarzDataScale(schwarz_data) = scale;

   return nalu_hypre_error_flag;
}

NALU_HYPRE_Int
nalu_hypre_SchwarzReScale( void *data, NALU_HYPRE_Int size, NALU_HYPRE_Real value)
{

   NALU_HYPRE_Int i;
   NALU_HYPRE_Real *scale;
   nalu_hypre_SchwarzData  *schwarz_data = (nalu_hypre_SchwarzData*) data;

   scale = nalu_hypre_SchwarzDataScale(schwarz_data);
   for (i = 0; i < size; i++)
   {
      scale[i] *= value;
   }

   return nalu_hypre_error_flag;

}

NALU_HYPRE_Int
nalu_hypre_SchwarzSetDofFunc( void *data, NALU_HYPRE_Int *dof_func)
{

   nalu_hypre_SchwarzData  *schwarz_data = (nalu_hypre_SchwarzData*) data;

   nalu_hypre_SchwarzDataDofFunc(schwarz_data) = dof_func;

   return nalu_hypre_error_flag;
}
